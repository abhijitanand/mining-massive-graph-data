\section{Related Work - Graph Indexing}
\label{sec:rel-work-indexing}

Indexing graphs for supporting graph primitives -- like \emph{shortest paths, reachability, graph isomorphism, finding dense subgraphs} have -- have recieved considerable attention. We divide the work done so far on indexing graphs, for each primitive operation, based on the type of query it supports -- ad-hoc or unknown queries or standing or known queries. 

\textbf{Reachability queries} Reachability queries are a fundamental operation in graph mining and algorithmics and ample work exists on index support for reachability problems. In this setting, given a directed graph and a designated source and target node, the task of the index is to determine whether the graph contains a path from the source to the target. The only technique that can cope with web- scale graphs while satisfying the requirements of restricted index size and fast query processing time, employs guided online search called GRAIL~\cite{yildirim2012grail}, leading to an index structure that is competitive in terms of its construction time and storage space consumption, yet speeds up reachability query answering significantly when compared to a simple DFS/BFS traversal of the graph. However, they suffer for sub-optimal usage of index space and also performance degradation on \emph{positive queries} (queries on which reachability actually exists, given that most reachability query workloads are negative queries). FERRARI~\cite{seufert2013ferrari} overcomes this problem by proposing a size-bounded indexing approach which performs well for positive queries. Other approaches for reachability indexing are based on direct indexing, i.e., answer a reachability query $(G, s, t)$ using just the labels assigned to $s$ and $t$. Apart from the classical algorithm proposed in~\cite{agrawal1989efficient} which compressed the computed transitive closure of the input graph, tree-, path- and chain-based approaches have also been proposed in~\cite{chen2008efficient,jagadish1990compression,jin2011path,wang2006dual}. However, none of these methods scale to Web data. Hop-based indexing methods, which instead of indexing covering structures maintains ancestors and descendants and uses fast intersections during querytime, were also explored in~\cite{cohen2003reachability,jin20093,schenkel2004hopi}. Another line of work in~\cite{trissl2007fast,yildirim2012grail}, tries to utilize scalable indices that can be used to speed up traditional online search to answer reachability queries.

\textbf{Shortest-path queries} The classic shortest path algorithm uses Breadth First Search implemented using a queue. However, this is prohibitive both in running time 
$\mathcal{O}(m + n log(n))$, where where n is the number of nodes and m is the
number of edges, or space complexity when we consider large graphs. In recent years, many efficient algorithms with preprocessing using indexing~\cite{goldberg2005computing,gutman2004reach} have been proposed for finding the shortest paths. For general
graphs, it has been shown that constant query time for exact shortest path distance queries is only achievable with superlinear space requirements during preprocessing [26]. Relaxing the exactness requirement, a number of distance oracles
have appeared which aim at providing a highly accurate estimate
of the node distances \cite{sankaranarayanan2009distance,zwick2001exact,thorup2005approximate}. Notable is the work done in~\cite{gubichev2010fast,das2010sketch} which in turn is based on the classical \emph{landmark based approach} used in distance oracles~\cite{thorup2005approximate}. More to be added on sketch based shortest paths...

